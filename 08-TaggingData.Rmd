# Tagging data and studies {#tagdata}
Since 1972 there have been approximately 400 000 sablefish tagged in Alaska waters, of which over 38 500 have been recovered. Although there is extensive and long term tagging data, this information is not currently directly included in the stock assessment [@goethel2021assessment].

## Integrating tagging observations in spatial age-structured models

This project intends to explore a range of methods for utilising tag-recovery observations in spatially disaggregated age-structured stock assessments.


## Releasing tags {-}
Tag release events involve releasing a tag-cohort at the beginning of a year within a specific area assumes tag cohort indexed by \(k\) has an implied year \(y\) and region \(r\) index. \(\boldsymbol{N}^k\) is used to denote a vector of lengths or ages for tag-cohort \(k\). In general, only the length frequency is known at time of release for each tag-cohort. We explore two different methods for seeding tagged numbers at age for each tag-cohort within spatial age-structured models. The two methods are either do it internal or external. The internal method requires users to supply length frequency for each tag-cohort and the model will use the assumed growth assumptions to convert the lengths to ages. The external approach is to use an age-length key outside of the model to derive an age frequency that can be supplied to the model. 

A frequent assumption of age-structured tagging models in the literature [@maunder1998integration;@vincent2020parameter] is that the age-frequency of each tag-cohort are known. Due to the fact that ageing is a fatal process, we assume they use an age-length key to convert lengths to ages. If the age-length key is representative of the vulnerable population at the time of tagging, then this method is expected to be have better computational performance. Factors to consider at time of release are; Gear method used to select releases, where releases occur, and time of releases. The internal method can attribute the correct age-distribution if the selectivity/availability by age is correct i.e. using the correct selectivity. Also, if growth is internally estimated within the assessment model, then the internal method may be prefered as to keep the growth assumptions consistent between LF observations and tagging observations.


One consideration if the tag releases and recoveries are both length-based is the age-length transition assumptions. Due to age-structured modelling growth as length conditional on age. Moving individuals back and forwards through the age-length transition matrix (length $\rightarrow$ age $\rightarrow$ length) will cause "smearing" of length frequencies. This is demonstrated in Figures \@(ref:addagelength) and \@(ref:showagelengthtransition_problem), and needs to be considered when considering model fitted values for observations and corresponding likelihood assumptions. Given this phenomenon, it could be argued, that the external age-length key approach is better as it makes these assumptions explicit (more transparent). However, both methods will be affected by this growth transition phenomenon to one degree or another. 

```{r addagelength, out.width = '70%', echo = F, eval = T, fig.cap='An example of theoretical length at age, with overlapping length bins used to describe the effect of going back and fourth through the age-length transition matrix.'}
ages = c(1:30) # as.numeric(names(ibm_out$init_1$values))
lens_bins = c(seq(from = 4, to = 10, by = 2), 11:81) # ibm_out$model_attributes$length_mid_points
lens = lens_bins[1:(length(lens_bins) - 1)] + diff(lens_bins) / 2

## simple illustrations
example_ages = 1:3
mean_length = c(13,19,24)
len_bins = seq(10,35,by = 5)
len_midpoints = len_bins[1:5] + diff(len_bins)/2
## randomly get some ages and lengths
Num_age = #rowSums(prob_length_given_age_matrix[c(6,9,13),c(32,35,42,45,50)]) / 100
  c(1757.704, 4320.569, 3129.675)
cv = 0.13
## generate age-length probability transition matrix used in age-based models
prob_length_given_age = matrix(0.0, nrow = length(example_ages), ncol = length(len_bins) - 1)
for(age_ndx in 1:length(example_ages)) {
  for(len_ndx in 2:length(len_bins)) {
    if (len_ndx == 2) {
      prob_length_given_age[age_ndx, len_ndx - 1] = pnorm(len_bins[2], mean_length[age_ndx], mean_length[age_ndx] * cv)
    } else if (len_ndx == length(len_bins)) {
      prob_length_given_age[age_ndx, len_ndx - 1] = 1 - pnorm(len_bins[length(len_bins) - 1], mean_length[age_ndx], mean_length[age_ndx] * cv)
    } else {
      prob_length_given_age[age_ndx, len_ndx - 1] = pnorm(len_bins[len_ndx], mean_length[age_ndx], mean_length[age_ndx] * cv) -  pnorm(len_bins[len_ndx - 1], mean_length[age_ndx], mean_length[age_ndx] * cv)
    }
  }
}

Cols = colorRampPalette(brewer.pal(n = 7, name = "Blues"))(5)[2:5]
plot(1:40, 1:40, type = "n", xlab = "Length", yaxt = "n", ylab = "Frequency", xlim = c(7,35), ylim = c(0,800), main = "Example length at age distribution")
temp_lens = 1:40
probs = seq(0.01,0.99, length = length(temp_lens))
for(i in 1:length(example_ages)) {
  lines(y = Num_age[i] * dnorm(temp_lens, mean_length[i], cv *  mean_length[i]) / sum(dnorm(temp_lens, mean_length[i], cv *  mean_length[i])), x = temp_lens, lwd = 3, col = Cols[i])
}
text(x = mean_length, y = 238, labels = paste0("a = ",example_ages), cex = 1.1, col= Cols)
text(x = len_midpoints, y =  773, labels = c(expression(l[1]),expression(l[2]),expression(l[3]),expression(l[4]),expression(l[5])), cex = 1.5, col= "red")

abline(v = len_bins, lty = 2, col = "red", lwd = 2)
group_name =  c(expression(l[1]),expression(l[2]),expression(l[3]),expression(l[4]),expression(l[5]))
```


```{r showagelengthtransitionproblem, out.width = '100%', fig.height= 4, fig.cap="A visualisation of the effect of going back and forth through an age-length transition matrix. This can happen when tag releases and recaptures are input as length in an age-structured model. The model converts lengths to ages, then reconverts the age to length for observations. This is assuming the same age-length relationship in Figure \\@ref(fig:addagelength)", echo = F, eval = T}
#############
# A fish in length bin l2
#############
# probability of length given age = prob_length_given_age
#rowSums(prob_length_given_age)
# What about probability of age given length? re-scale
prob_age_given_length = sweep(prob_length_given_age, STATS = colSums(prob_length_given_age), MARGIN = 2, FUN = "/")

dimnames(prob_length_given_age) = dimnames(prob_age_given_length)  = list(example_ages, len_midpoints)
prob_length_given_age_long = melt(prob_length_given_age)
colnames(prob_length_given_age_long) = c("age", "length","prop")
prob_length_given_age_long$age = factor(prob_length_given_age_long$age)
prob_length_given_age_long$length = factor(prob_length_given_age_long$length)

prob_length_given_length_long = melt(prob_age_given_length)
colnames(prob_length_given_length_long) = c("age", "length","prop")
prob_length_given_length_long$age = factor(prob_length_given_length_long$age)
prob_length_given_length_long$length = factor(prob_length_given_length_long$length)

test = ggplot(prob_length_given_length_long, aes(fill=age, y=prop, x=length)) + 
  geom_bar(position="stack", stat="identity") +
  xlab("Numbers") +
  ggtitle("Age composition conditioned on length bin")+
  scale_x_discrete(labels=group_name)  # Ad

test_alt = ggplot(prob_length_given_age_long, aes(fill=length, y=prop, x=age)) + 
  geom_bar(position="stack", stat="identity") +
  xlab("") +
  ggtitle("Length composition conditioned on age")+
  scale_fill_discrete(labels=group_name)  # Ad

## In an age based model
## A single Fish in length bin = 2, equates to the following ages
age_from_l2 = prob_age_given_length[,2]
#age_from_l2
## The model derived lenght distribution of this
model_length = age_from_l2 %*% prob_length_given_age
#model_length

P1 = ggplot(data = data.frame(length = factor(len_midpoints), result = c(0,1,0,0,0)), aes(y=result, x=length)) + 
  geom_bar(position="dodge", stat="identity") +
  ylab("Numbers") +
  xlab("Length bin") +
  ylim(0,1) +
  ggtitle(substitute(paste("Single fish in length bin = ", l[len_ndx]), list(len_ndx = 2))) +
  theme(axis.text.x=element_text(size=15),axis.text.y=element_text(size=15),
        axis.title=element_text(size=15,face="bold"),
        title =element_text(size=13)) +
  scale_x_discrete(labels=group_name) +
  theme_bw()

P2 = ggplot(data = data.frame(age = factor(example_ages), result = age_from_l2), aes(x = age, y = result)) + 
  geom_bar(position="dodge", stat="identity") +
  ylab("") +
  ylim(0,1) +
  ggtitle(substitute(paste("Age disribution of fish in length bin = ", l[len_ndx]), list(len_ndx = 2))) +
  theme(axis.text.x=element_text(size=15),axis.text.y=element_text(size=15),
        axis.title=element_text(size=15,face="bold"),
        title =element_text(size=13)) +
  theme_bw()



P3 = ggplot(data = data.frame(length = factor(len_midpoints), result = as.numeric(model_length)), aes(y=result, x=length)) + 
  geom_bar(position="dodge", stat="identity") +
  ylab("") +
  ylim(0,1) +
  xlab("Length bin") +
  ggtitle(substitute(paste("Length distribution of initial fish = ", l[len_ndx]), list(len_ndx = 2))) +
  theme(axis.text.x=element_text(size=15),axis.text.y=element_text(size=15),
        axis.title=element_text(size=15,face="bold"),
        title =element_text(size=13)) +
  scale_x_discrete(labels=group_name) +
  theme_bw()# Ad


P1 = P1 + geom_segment(aes(x = 4, y = 0.5, xend =5, yend = 0.5, size = 1),
               arrow = arrow(length = unit(1, "cm")), col = "red") +
  guides(size = "none")
P2 = P2 + geom_segment(aes(x = 3.8, y = 0.5, xend =5, yend = 0.5, size = 1),
                 arrow = arrow(length = unit(1, "cm")), col = "red") +
  guides(size = "none")
grid.arrange(grobs = list(P1, P2, P3), nrow = 1)
```

#### Internal method {-}
Age-structured stock assessment models contain growth models, which describe length conditioned on age. This requires assumptions on the distribution and associated parameters. The default is often the normal distribution with mean length at age denoted by \(\bar{l}_a\) with standard deviation parameterised as a coefficient of variation (\(\sigma_a = cv*\mu_a\)). This information enables the model to derive a growth transition matrix \(P_{l|a}\). Given the lower and upper limits for each length bin denoted as \(\boldsymbol{b} = (b_1, b_2, \dots, b_{max})'\), the probability of being in length bin \(l\) given age \(a\)

\begin{equation}
P_{l|a} = 
\begin{cases}
\Phi(b_{l + 1}|\mu_a,\sigma_a)\quad &\text{for } l = 1\\
\Phi(b_{l + 1}|\mu_a,\sigma_a) - \Phi(b_l|\mu_a,\sigma_a)\quad &\text{for } 1 < l < n_l\\
1 - \Phi(b_{l}|\mu_a,\sigma_a)\quad &\text{for } l = n_l
\end{cases}
  (\#eq:agelengthtransition)
\end{equation}


where \(\Phi(x|\mu,\sigma)\) is the cumulative normal (but could be generalised to any probability distribution). If growth varies by attributes such as sex, stock or region then this will need to be calculated for each growth model. In the SNA1 stock assessment each stock has a different growth curve and is denote as \(P^s_{a|l}\)

At the point a tag cohort is released, the model can derive the length composition of the vulnerable population using the transition matrix derived in Equation \ref(eq:agelengthtransition). Given the number of estimable parameters that govern the age-stricture at a point in time and growth model, an exploitation rate is calculated so that if there are not enough numbers in a length bin to be tagged, a penalty can be added to the objective function to dissuade the combination of parameters that generated this situation. Tag-release by length is a known quantity and so the model must allow for a minimum vulnerable length composition to that released. To enforce this a exploitation like rate by each length \((u_l)\) is calculated as follows,
\begin{equation}
u_l = \frac{N^k_{l}}{\sum_a}N_{y_k,a,r_k} P_{l|a}
  (\#eq:lengthexploit)
\end{equation}

During parameter estimation there are no constraints within the model to trial a set of parameters than will allow \(u_l > 1\) i.e. more observed tag-releases than in the vulnerable population. To stop negative numbers at age \(u_l\) is set at a level less than 1 and a penalty added to the objective function to discourage parameters from allowing this condition. Finally tag-release at age is calculated as follows,
\begin{equation}
N^k_{a} = N_{y_k,a,r_k}  P_{l|a} u_l
  (\#eq:tagatagerelease)

\end{equation}

Once the tag cohort are created in the model it is assumed that tagged fish are exposed to the same dynamics as un-tagged fish.


#### External method (Age-length key method) {-}
Once a tag-release event has occurred for tag group \(k\), the only known knowledge is the length distribution \(N^k_l\). Assuming there is an accessible forward age-length key which describes the proportion of ages for a given length bin \(\left(P_{a|l}\right)\) that is representative of the vulnerable population to tagging for the same area and time, then the "forward" or "classic" key method can be used @ailloud2019general. If tag-release coincide with a fishing season you could use fishery-dependent derived age length information, assuming the selectivity curves within a length bin are parallel. If only a subset of fish from each haul is released, it would be better to construct an age-length key from a representative sample of fish that were caught by not-tagged. This would be relevant for single vessel survey release events.
\begin{equation}
	N^k_a = \sum\limits_{l = 1}P_{a|l}N^k_l
\end{equation}
where, \(N^k_a\) is used as an known input into the model with no error. 


#### Things to consider for tag release {-}

- we don't have much information regarding sex of tagged fish (36.5\% of recovered tags have sex information). Does this lean towards the internal method? can allocate sex ratio based on vulnerable population which may be important, if there is quite a difference in sex disaggregated selectivities.


## Tag recovery observations {-}
There are tow types of tag-recovery observations that we will consider in this work, tag-release conditioned and tag-recapture conditioned. This conditioning relates to whether we relate recoveries to the release event or whether we only look at the recoveries relative to other recoveries within a year [@vincent2020parameter;@mcgarvey2002estimating]. This conditioning relates more to the log-likelihood formulation rather than the model fitted values. We will also explore two different approaches regarding the scanned fish of which tag-recoveries are a subset. The first is recoveries were entirely from a fishery which requires some understanding or assumptions on reporting rates. The other method assumes scanned fish are known, which is the approach used in the Casal2 [@doonan2016casal2] stock assessment program. This information can be recorded if the scanning is done either by observers who are recording LF's for the catch or scientific/trained staff when shed sampling landed catch. Both these scanning approaches will require an assuming or information on detection rates.

#### Things to consider for tag recovery data {-}

- Years to retain tagged fish in the partition
- Reporting rates
- Scan detection rates
- Mixing time
- Tag loss
- Release conditioning vs recapture conditioning
- likelihood choice?





## Growth estimation using the Laslett–Eveson–Polacheck (LEP) method 
Going to investigate the use of “Laslett–Eveson–Polacheck (LEP)” based on @laslett2002flexible \& @eveson2004integrated as described in @aires2015improved.


The idea is to use a single growth model that fits to two observational data sets (ideally within the assessment, however we will start outside for now. When including it in the assessment you will also have LF data to help inform growth). The first will describe age-at-length data from direct ageing. The second will be length increment data from tagging experiments. 


### Age-at-length growth model {-}

We start by using the Richards growth curve following @aires2015improved (but this could be extended). The Richards growth formulation follows

\begin{equation} 
  \bar{l}_{a} = L_{\infty} \left( 1 + \frac{1}{p} \exp \{-K(a - a_0)\}\right)^{-p}
  (\#eq:richardsgrowth)
\end{equation} 
where, \( \bar{l}_{a}\) is the mean length at age \(a\), \(L_{\infty}\) is the asymptotic length, \(K\) is the growth coefficient and \(p\) is a shape parameter that is related to the ratio \(\bar{l}_{a} / L_{\infty}\) at the inflexion point.

### Tag recapture growth data {-}
+----------------------------+-----------------------------------------------------------------------------+
| Symbol                     | Description                        
+============================+=============================================================================+
| \(l_{1,i}\)                | length of individual \(i\) at release
+----------------------------+-----------------------------------------------------------------------------+
| \(l_{2,i}\)                | length of individual \(i\) at recapture
+----------------------------+-----------------------------------------------------------------------------+
| \(a_{1,i}\)                | age of individual \(i\) at release. Denoted as \(A\) in @aires2015improved
+----------------------------+-----------------------------------------------------------------------------+
| \(a_{2,i}\)                | age of individual \(i\) at recapture
+----------------------------+-----------------------------------------------------------------------------+
| \(\Delta_t\)               | Time at liberty \(\Delta_t = a_{2,i} - a_{1,i}\)      
+----------------------------+-----------------------------------------------------------------------------+
**Just one comment on notation!!!** in most all the papers that use this method, they ignore the individual notation of \(A\). That is not an issue in general however it confuses me when they describe the prior on this.


The sub-models for the release and recapture lengths follow,
\begin{equation} 
  l_{1,i} = L_{\infty} \left( 1 + \frac{1}{p} \exp \{-K(a_{1,i} - a_0)\}\right)^{-p}
  (\#eq:lengthatrelease)
\end{equation} 

and,
\begin{equation} 
  l_{2,i} = L_{\infty} \left( 1 + \frac{1}{p} \exp \{-K(a_{1,i} + \Delta_t - a_0)\}\right)^{-p}
  (\#eq:lengthatrecapture)
\end{equation} 


The above growth model assumes that we know the age at recovery \(a_{2,i}\). The problem we have is, we have 22 569 tag recoveries with length information but only a handful of these have been aged. This is dealt with by modelling \(a_{1,i}\) as a random effect i.e., \(a_{1,i} \sim LN \left(\mu, \sigma^2\right)\).

What confuses is me here is how to assign a hyper distribution like the one above for the random effect variables \(a_{1,i}\). \(a_{1,i}\) is expected to vary quite a bit because tagged fish at release have a broad length frequency and thus is expected to have a broad age at release? (ask someone about this because I may be misunderstanding something).

## Simulation test the "LEP" method {-}

```{r, simulate_data, echo = T, eval = T}
## going to use parameters from Aires-da-Silva et al. (2015) Table 1 integrated analysis
L_inf = 200.8
k = 0.44
t_0 = 1.26
p = -4.27
cv = 0.15 ## cv of length around length at age

## selectivity paraemters
sel_a50 = 1.3
sel_ato95 = 0.8
## sample sizes for simulation
n_sample_release = 1000
n_sample_recoveries = 1000 * 0.1 ## about the recovery rate from sablefish data
n_sample_age_length = 1000

## generate a pseudo age structure
set.seed(123)
R_0 = 200000
M = 0.29
ages = 1:20
n_ages = length(ages)
#plot(ages, mean_length_at_age, type = "l", lwd = 3, xlab = "Age", ylab = "Length (cm)")
sel_at_age = logis(ages, sel_a50, sel_ato95)

## numbers at age
N_age = vector(length = n_ages, "numeric")
for (age_ndx in 1:n_ages) 
  N_age[age_ndx] = R_0 * exp(-ages[age_ndx] * M) * exp(rnorm(1,0,0.7))

N_age = N_age * sel_at_age ## vulnerable numbers at age

plot(ages, N_age, ylab = "Numbers", xlab = "Age", main = "Population age-structure", type = "o")

## plot growth
mean_length_at_age = richards_growth(ages, p, k, t_0, L_inf)
## randomly sample 1000 individuals with replacement for otolithing no ageing error!!
## 
individual_age_length_df = NULL
for(i in 1:n_sample_age_length) {
  age_i = sample(1:n_ages, size = 1, prob = N_age)
  mean_length_i = richards_growth(age_i, p, k, t_0, L_inf)
  length_i = rnorm(1, mean_length_i, mean_length_i * cv)
  temp_df = data.frame(age = age_i, length = length_i)
  individual_age_length_df = rbind(individual_age_length_df, temp_df)
}

## Simulate a tag-recapture experiment 
# releases
release_ages = sample(1:n_ages, size = n_sample_release, prob = N_age, replace = T)
release_mean_lengths = richards_growth(release_ages, p, k, t_0, L_inf)
release_lengths = rnorm(n_sample_release, release_mean_lengths, release_mean_lengths * cv)
individual_release_df = data.frame(release_age = release_ages, release_length = release_lengths, release_mean_length = release_mean_lengths)
individual_release_df$fish_id = 1:nrow(individual_release_df)

# recaptures sample uniformly without replacement
fish_ndx = sample(1:nrow(individual_release_df), size = n_sample_recoveries, replace = F) 
individual_recovery_df = subset(individual_release_df, subset = individual_release_df$fish_id %in% fish_ndx)
## time-at liberty days randomly recovered on average between 100-600 days
individual_recovery_df$time_at_liberty = rpois(n = n_sample_recoveries, lambda = runif(n_sample_recoveries,100,600))
individual_recovery_df$recovery_age = individual_recovery_df$release_age + individual_recovery_df$time_at_liberty/365
## how to add the length increment between release and recovery?
individual_recovery_df$recovery_mean_length = richards_growth(individual_recovery_df$recovery_age, p, k, t_0, L_inf)
individual_recovery_df$recovery_mean_length_increment = with(individual_recovery_df, recovery_mean_length - release_mean_length)
individual_recovery_df$recovery_length = with(individual_recovery_df, release_length + rlnorm(n_sample_recoveries, log(recovery_mean_length_increment), cv))
individual_recovery_df$growth_change = individual_recovery_df$recovery_length - individual_recovery_df$release_length 

## visualise length at age samples
ggplot(individual_age_length_df, aes(x = age, y = length)) +
  geom_point() +
  geom_line(data= data.frame(length = mean_length_at_age, age = ages), aes(x = age, y = length), col = "red", linewidth = 1.2, inherit.aes = F) +
  labs(x = "Age", y = "Length") +
  ylim(0,NA)
```

Assumptions in the above OM follow.

\[
l_{1,i} \sim \mathcal{N} \left(\bar{l}_{1,a}, \sigma = \bar{l}_{1,a} \times cv\right)
\]
where the mean length at age release (\(\bar{l}_{1,a}\)) follows the Richards growth curve defined in Equation \@ref(eq:richardsgrowth). The age used to derive the mean length at age was a random sample with replacement from the population in shown in the earlier figure. Time at liberty was drawn from a Poisson distribution with a rate parameter randomly drawn from a uniform distribution between 100-600 days. The age at recovery \(a_{2,i} = a_{1,i} + \Delta_t\). An approximation was made when calculating the length at recovery. The length increment (\(l_{\Delta_t}\)) was simulated using a Log Normal distribution with the median set based on the difference between mean length at release age and mean length at recovery age. This was to ensure all recovered fish positively grew at a rate expected by the growth model (less than ideal but will do for now).
\[
l_{i,\Delta_t} \sim \mathcal{LN} \left(\ln (\bar{l}_{a_{2,i}} - \bar{l}_{a_{1,i}}), \sigma = cv\right)
\]

\[
l_{2,i} = l_{1,i} + l_{i, \Delta_t}
\]
In theory we can now pass this data to our LEP model to back estimate growth parameters.


```{r,compile_TMB_model, echo = T, results = 'hide', eval = T}
setwd(file.path("TMB"))
#sink(file = "compile_output.txt")
compile(file = "LEPgrowth_model.cpp", flags = "-Wignored-attributes -O3")
#sink()
dyn.load(dynlib("LEPgrowth_model"))
#setwd(DIR$book)
```


```{r, build_TMB_model, echo = T, eval = T, results = 'hide'}
# data
data = list()
data$ages_from_age_length = individual_age_length_df$age
data$lengths_from_age_length = individual_age_length_df$length
data$lengths_at_release = individual_recovery_df$release_length
data$lengths_at_recovery = individual_recovery_df$recovery_length
data$time_at_liberty = individual_recovery_df$time_at_liberty / 365
data$ages_for_report = ages;

data$p_bounds = c(-20, 20)
data$t0_bounds = c(-6, 4)

# parameters
parameters = list()
parameters$ln_cv_length_at_age = log(cv)
parameters$ln_k = log(k)
parameters$ln_L_inf = log(L_inf)
parameters$logit_p =  logit_general(p, data$p_bounds[1],data$p_bounds[2])
parameters$logit_t0 =  logit_general(t_0, data$t0_bounds[1],data$t0_bounds[2])
parameters$ln_cv_length_release = log(0.1)
parameters$ln_cv_length_recovery = log(0.1)
parameters$ln_age_at_release = log(individual_recovery_df$release_age)

parameters$ln_mu_age_release = log(3)
parameters$ln_sd_age_release = log(1)

obj_mixed_all <- MakeADFun(data, parameters, random = "ln_age_at_release", DLL="LEPgrowth_model")
```


```{r, optimise_TMB_model, echo = T, eval = T, results = 'hide'}
MLE_mixed_all = nlminb(start = obj_mixed_all$par, objective = obj_mixed_all$fn, gradient  = obj_mixed_all$gr)
MLE_mixed_all$convergence
MLE_mixed_all_rep = obj_mixed_all$report(obj_mixed_all$env$last.par.best)
MLE_mixed_all_sd_rep = sdreport(obj_mixed_all)
plot(ages, MLE_mixed_all_rep$mean_length_at_age, type = "l", lwd = 3, col = "red", xlab = "Age", ylab = "Length (cm)", ylim = c(0, 240))
lines(ages, mean_length_at_age, col = "blue", lty = 3, lwd = 3)
legend('bottomright', legend = c("LEP obs error","True"), col = c("red", "blue"), lty = c(1,2), lwd = 3)

```


## Next steps {-}

- Check sensitivity to the model to starting parameters 
- Repeat with different sample sizes
- Repeat with a truncated age-structure for the age-length data using a selectivity
- Look at Sablefish data and see if the LEP approach can be used to it
- Explore alternative growth models i.e., @schnute1981versatile






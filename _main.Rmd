--- 
title: "Alaskan sablefish research"
author: "C.Marsh"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
includes:
 before_body: preamble-mathjax.tex
#url: https:///r4Casal2/
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This Gitbook documents my post-doctoral research relating to Alaskan sablefish.
link-citations: yes

---

# cover-image: path to the social sharing image like images/cover.jpg

Placeholder


## Gitbook outline  {-}
## Future things to consider {-}

<!--chapter:end:index.Rmd-->

# A list of objectives/milestones that we have set along the project life {#objectives}


- [x]  Translate current stock assessment (Chapter \@ref(modeldescription)) from ADMB to TMB. Planned date of completion is December 1 2022
- [ ]  ~~Conduct self test using TMB stock assessment model. Planned date of completion is December 1 2022~~ I decided not to do this because the assessment had too many bespoke likelihoods
- [x]  Consider improvements i.e., sex disaggregated composition data or sex ratio observations (look at the rock lobster assessment) including age-length observations or tag-increment observations to estimate growth internally. (Chapter \@ref(sexratios))
- [x]  Characterize both fishery and survey data to get an idea of data limitations when considering spatially explicit stock assessment model.
- [x]  Develop a spatially explicit estimation model in TMB that generalizes the current assessment model. This requires a lot of thought, especially how we want to integrate the tagging data (Chapter \@ref(tagdata)). Self test has been complete without tagging data.
- [x]  Generate observation error values for composition data. either boostrap or use SE methods
- [ ]  ~~Calculate mean length at age for each year - perhaps use the growth model, but this may be double using some of the datasets? This is an interesting idea cause if we take the tag data for example it would be used to estimate mean length at age just using increment and time at liberty, where as when it is internally used in the model it would be using age-frequency to estimate ontogenetic movement.~~ I decided to default to the current assessment length at age and mean length assumptions

- [x]  Outline key model decisions based on data exploration (Chapter \@ref(InitialModelSetup))
- [x]  Display initial model runs (Chapter \@ref(modelIterations))
- [x]  Develop projections and reference point calculations for spatial models 
- [ ]  Develop summary diagnostics to better identify model misfits summarise over dimensions
- [ ]  Start running model permutations and conducting model comparisons




<!--chapter:end:01-Objectives.Rmd-->


# Current Alaskan sablefish stock assessment model {#modeldescription}

Placeholder


## Process equations {-}
### Initialisation \left(\(g\left(.\right)\)\right) {-}
### Population dynamics \left(\(f\left(.\right)\)\right) {-}
## Observation equations (\(ll\left( . \right)\)) {-}
### Catch at age {-}
### Relative abundance indices {-}
### Catch at length {-}
## Symbol Notation {-}
### Inference {-}
### TODO {-}

<!--chapter:end:02-CurrentAssessmentModel.Rmd-->


# Spatial stock assessment model for Alaskan sablefish {#spatialmodeldescription}

Placeholder


## Process equations {-}
### Population dynamics {-}
### Initialisation {-}
### Growth {-}
### Recruitment {-}
### Fishing mortality {-}
### Tag release events {-}
## Observation equations {-}
### Catch at age {-}
### Catch at length {-}
### Proportions at age {-}
### Relative abundance indices {-}
### Tag recovery observations {-}

<!--chapter:end:03-SpatialAssessmentModel.Rmd-->


# Survey data {#surveydata}

Placeholder


## Survey design {-}
## Abundance (catch rate) data {-}
## Age data {-}
## Length frequencies {-}
## Age frequencies {-}
### Direct ageing estimators
### Age length key estimators
### Continuation ratio logits (CRL) {-}
### Estimating initial input sample sizes for multinomial composition data {-}
## Age-length data {-}
## Appendix {-}

<!--chapter:end:04-SurveyData.Rmd-->


# Fishery dependent data {#observerdata}

Placeholder


## Catch data {-}
## Length data {-}
### Catch at length estimator {-}
## Age data {-}
## Age-length data {-}

<!--chapter:end:05-FisheryDependentData.Rmd-->


# Tagging data exploration {#tagdata}

Placeholder


## Data grooming {-}
## Exploratory analysis of the tag data {-}
## Single area recovery model {-}
## Lincoln-Peterson estimator {-}
## Integrating tagging observations in spatial age-structured models {-}
## Tagging things to consider with relevant references {-}
## Releasing tags {-}
#### Internal method {-}
#### External method (Age-length key method) {-}
### Things to consider for tag release {-}

<!--chapter:end:06-TaggingData.Rmd-->


# Initial model setup {#InitialModelSetup}

Placeholder


## Model start time {-}
## Model spatial resolution of the model {-}
## Fishery structure {-}
## Repeat regression analysis on survey LF data {-}

<!--chapter:end:07-SpatialModelConfiguration.Rmd-->


# Model iterations {#modelIterations}

Placeholder


## Single Area model {-}
### Include tagging data {-}
## Three area model {-}
## Five area model {-}
### Issues {-}
## Comparison {-}

<!--chapter:end:08-ModelIterations.Rmd-->


# Five area model permutations {#FiveAreaModel}

Placeholder


## Notes about this model {-}

<!--chapter:end:09-5AreaModel.Rmd-->

# Next steps {#nextsteps}

- Run log likelihood profiles on Female Trawl selectivity parameters. Profiles are very sporadic, when I force males and females to have the same selectivity it does produce sensible answers selectivity curves.

- Apply the Dirichlet-Multinomial likelihood for compositional data
- Start model 1990
- Generate reference points and ABCs


## Simulation Scenarios {-}


- What effect loosing early time-periods has on the assessment advice. The spatial models started much later in the time-series than when significant exploitation occured, which is a common issue with spatial models due to historical data not haveing spatial resolution to be used. This early period coincides with the largest removals in the time-series which is thought to be valuable to observe for observering contrast and helping estimate stock production [@hilborn1979comparison] this claim is actually countered by @magnusson2007makes.

- What bias can we expect when we assume a closed population when in fact there is emigration outside of the stock boundary

- Consequence in assuming a three region model when in fact there is five regions based on the Regression break points.

- Spatial recruitment process and reference point consequences. Time-varying recruit devs by region vs time-varying recruitment deviations constant across 

- age-varying movement? spasm paper to reference time-vs age varying movement.

<!--chapter:end:12-NextSteps.Rmd-->

# Estimating age-based movement {#agebasedmovement}

To explore estimating age-based movement a simple age-based tagging process model was coded, which assumed

\begin{align*}
T^k_{a, r,t} & = T_a^k, \quad t = 0\\
T^k_{a, r,t + 1} & = T^k_{a, r,t} e^{-M}, \quad t > 0\\
\boldsymbol{T}^k_{a, t + 1} & = \boldsymbol{T}^k_{a, t + 1} (1 - S^o_a)  \boldsymbol{M}^y + \boldsymbol{T}^k_{a, t + 1}  S^o_a \boldsymbol{M}^o
\end{align*}
where, \(T_a^k\) is the initial number of tag releases for release event \(k\) and age \(a\), \(\boldsymbol{T}^k_{a, t + 1}\) is a matrix of numbers of tagged fish across all regions from release event \(k\) and age \(a\), \(\boldsymbol{M}^y\) is a \(n_r \times n_r\) movement matrix for young fish and \(\boldsymbol{M}^o\) is the movement matrix for older fish. \(S^o_a\) is a movement based logistic ogive that determines what proportion of age-cohorts move based on \(\boldsymbol{M}^o\) and \((1 - S^o_a)\) indicates what proportion of age-cohorts move based on \(\boldsymbol{M}^y\)



Generating age-based observation model 

\begin{align*}
\widehat{Y}^k_{r,t} & = \sum_a \widehat{T}^k_{a, r,t}(1 - \widehat{S}^o_a) \\
\widehat{O}^k_{r,t} & = \sum_a \widehat{T}^k_{a, r,t} \widehat{S}^o_a \\
{Y}^k_{r,t} & = \sum_a N^k_{a, r,t}(1 - \widehat{S}^o_a) \\
{O}^k_{r,t} & = \sum_a N^k_{a, r,t} \widehat{S}^o_a \\
\end{align*}

\(\widehat{Y}^k_{r,t}\) expected tag recoveries for young fish, and \(\widehat{O}^k_{r,t}\) is the expected tag recoveries for old fish, and \( N^k_{a, r,t}\) is the observed tag-recovery by age.




The following section is code and plots from running three simulations,

1.  Estimate movement matrix for young (\(\boldsymbol{M}^y\)) and old  (\(\boldsymbol{M}^o\)) with age-based ogive fixed at OM values
2.  Estimate movement matrix for young (\(\boldsymbol{M}^y\)) and old  (\(\boldsymbol{M}^o\)) with age-based ogive fixed at OM values




```{r loadagebasedTMBmodel, echo = F, eval = T, results = 'hide', warning=FALSE, message=FALSE, error = FALSE}
compile(file.path("TMB","SimpleAgeBasedMovement.cpp"), flags = "-Wignored-attributes -O3",DLLFLAGS="");
dyn.load(dynlib(file.path("TMB","SimpleAgeBasedMovement")))
```


```{r SetupAgeBasedOM}
M = 0.12
R0 = 20000
ages = 1:30
n_regions = 3
young_move_matrix = old_move_matrix = matrix(rnorm(n_regions * n_regions, 10, 3), nrow = n_regions, ncol = n_regions)
## young movement
## encouraged to stay closer to region 1
young_move_matrix[1,1] = 0.75
young_move_matrix[1,2] = 0.2
young_move_matrix[1,3] = 0.05

young_move_matrix[2,1] = 0.3
young_move_matrix[2,2] = 0.6
young_move_matrix[2,3] = 0.1

young_move_matrix[3,1] = 0.6
young_move_matrix[3,2] = 0.3
young_move_matrix[3,3] = 0.1

## old movement
## encouraged to stay closer to region 3
old_move_matrix[1,1] = 0.1
old_move_matrix[1,2] = 0.4
old_move_matrix[1,3] = 0.5

old_move_matrix[2,1] = 0.1
old_move_matrix[2,2] = 0.5
old_move_matrix[2,3] = 0.4

old_move_matrix[3,1] = 0.1
old_move_matrix[3,2] = 0.2
old_move_matrix[3,3] = 0.7

true_young_molten_move = melt(young_move_matrix)
true_old_molten_move = melt(old_move_matrix)

colnames(true_young_molten_move) = colnames(true_old_molten_move) = c("From", "To", "movement")

## age based movement ogive
a50_move = 6.7
a95_move = 1.7
old_age_based_movement = logis(ages, a50_move, a95_move)
young_age_based_movement = 1 - old_age_based_movement

init_N_age = calculate_initial_numbers_at_age_age_based_movement(n_regions, n_ages = length(ages), R0, old_movement_matrix = old_move_matrix, young_movement_matrix = young_move_matrix, age_based_movement_ogive = young_age_based_movement, natural_mortality =rep(M, length(ages)))

data = list()
data$initial_age_tag_releases = t(init_N_age)
data$natural_mortality = M
data$n_years = 5
data$n_ages = length(ages)
data$n_regions = n_regions
data$ages = ages
data$tag_recovery_obs = array(100, dim = c(data$n_ages, n_regions, n_regions, data$n_years))
data$a50_bounds = c(3, 15)
parameters = list()
parameters$logisitic_a50_movement = logit_general(a50_move, data$a50_bounds[1], data$a50_bounds[2])
parameters$ln_ato95_movement = log(a95_move)

parameters$transformed_movement_pars_young = array(0, dim = c(n_regions - 1, n_regions))
parameters$transformed_movement_pars_old = array(0, dim = c(n_regions - 1, n_regions))

for(r in 1:n_regions) {
  parameters$transformed_movement_pars_young[,r] = simplex(young_move_matrix[r, ])
  parameters$transformed_movement_pars_old[,r] = simplex(old_move_matrix[r, ])
}
test_obj <- MakeADFun(data = data, parameters = parameters, DLL="SimpleAgeBasedMovement")

```


## Simulation with fixed age-based ogive {-}
Run a simulation with age-based movement ogive is fixed at correct values

```{r FixOgiveSim, echo = F}
###### set starting parameters
start_movement_matrix = matrix(rlnorm(n = n_regions * n_regions, log(0.01), 0.1), n_regions, n_regions)
# renormalise
start_movement_matrix = sweep(start_movement_matrix, 1, STATS = rowSums(start_movement_matrix), "/")

start_parameters = list()
start_parameters$logisitic_a50_movement = logit_general(4, data$a50_bounds[1], data$a50_bounds[2])
start_parameters$ln_ato95_movement = log(1)

start_parameters$transformed_movement_pars_young = array(0, dim = c(n_regions - 1, n_regions))
start_parameters$transformed_movement_pars_old = array(0, dim = c(n_regions - 1, n_regions))

for(r in 1:n_regions) {
  start_parameters$transformed_movement_pars_young[,r] = simplex(start_movement_matrix[r, ])
  start_parameters$transformed_movement_pars_old[,r] = simplex(start_movement_matrix[r, ])
}

n_sims = 250;
sim_ls = list();
young_age_based_ogive_df = old_age_based_ogive_df = NULL
young_matrix_df = old_matrix_df = NULL
a50_vec = ato95_vec = NULL
## fix selectivity parameters at true values
na_map = fix_pars(par_list = start_parameters, pars_to_exclude = c("logisitic_a50_movement","ln_ato95_movement"))
# fix at true values
start_parameters$logisitic_a50_movement = logit_general(a50_move, data$a50_bounds[1], data$a50_bounds[2])
start_parameters$ln_ato95_movement = log(a95_move)
nll = vector()
for(sim_iter in 1:n_sims){
  ## simulate data
  simdata = test_obj$simulate(complete = T)
  
  ## re-estimate
  reest_obj <- MakeADFun(data = simdata, parameters = start_parameters, map = na_map, DLL="SimpleAgeBasedMovement",
                         silent = T)
  #reest_obj$fn()
  #reest_obj$gr()
  ## Estimate
  mle_spatial = nlminb(start = reest_obj$par, objective = reest_obj$fn, gradient  = reest_obj$gr,
                       control = list(iter.max = 10000, eval.max = 10000))
  try_improve = tryCatch(expr =
                           for(i in 1:2) {
                             g = as.numeric(reest_obj$gr(mle_spatial$par))
                             h = optimHess(mle_spatial$par, fn = reest_obj$fn, gr = reest_obj$gr)
                             mle_spatial$par = mle_spatial$par - solve(h,g)
                             mle_spatial$objective = reest_obj$fn(mle_spatial$par)
                           }
                         , error = function(e){e})
  
  try_improve
  
  mle_report = reest_obj$report(mle_spatial$par)
  
  a50_vec = c(a50_vec, mle_report$a50_movement)
  ato95_vec = c(ato95_vec, mle_report$ato95_movement)
  
  
  young_ogive = data.frame(age = data$ages, ogive = mle_report$young_age_based_movement_ogive, sim = sim_iter)
  old_ogive = data.frame(age = data$ages, ogive = mle_report$old_age_based_movement_ogive, sim = sim_iter)
  
  young_age_based_ogive_df = rbind(young_age_based_ogive_df, young_ogive)
  old_age_based_ogive_df = rbind(old_age_based_ogive_df, old_ogive)
  
  young_matrix = mle_report$movement_matrix_young
  old_matrix = mle_report$movement_matrix_old
  
  young_molten_move = melt(young_matrix)
  old_molten_move = melt(old_matrix)
  
  colnames(young_molten_move) = colnames(old_molten_move) = c("From", "To", "movement")
  young_molten_move$sim = sim_iter
  old_molten_move$sim = sim_iter
  
  young_matrix_df = rbind(young_matrix_df, young_molten_move)
  old_matrix_df = rbind(old_matrix_df, old_molten_move)
  
  nll = c(nll, mle_spatial$objective)
}


## visualise young movement rates
ggplot(young_matrix_df) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_young_molten_move, aes(yintercept = movement, col = "OM"), 
             linewidth = 1.1, linetype = "dashed") +
  facet_grid(From~To) +
  ggtitle("Young movement rates") +
  ylim(0,1) +
  theme_bw()


ggplot(old_matrix_df) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_old_molten_move, aes(yintercept = movement, col = "OM"), 
             linewidth = 1.1, linetype = "dashed") +
  facet_grid(From~To)  +
  ggtitle("old movement rates") +
  ylim(0,1) +
  theme_bw()
```



## Simulation estimate a50 parameter of age-based ogive {-}


```{r Esta50Ogive, echo = F}
###### set starting parameters
sim_ls = list();
young_age_based_ogive_df_a50 = old_age_based_ogive_df_a50 = NULL
young_matrix_df_a50 = old_matrix_df_a50 = NULL
a50_vec = ato95_vec = NULL
## fix selectivity parameters at true values
na_map = fix_pars(par_list = start_parameters, pars_to_exclude = c("ln_ato95_movement"))
# fix at true values
start_parameters$logisitic_a50_movement = logit_general(4, data$a50_bounds[1], data$a50_bounds[2])
start_parameters$ln_ato95_movement = log(a95_move)
nll_a50 = vector()
for(sim_iter in 1:n_sims){
  ## simulate data
  simdata = test_obj$simulate(complete = T)
  
  ## re-estimate
  reest_obj <- MakeADFun(data = simdata, parameters = start_parameters, map = na_map, DLL="SimpleAgeBasedMovement", silent = T)
  #reest_obj$fn()
  #reest_obj$gr()
  ## Estimate
  mle_spatial = nlminb(start = reest_obj$par, objective = reest_obj$fn, gradient  = reest_obj$gr, control = list(iter.max = 10000, eval.max = 10000))
  try_improve = tryCatch(expr =
                           for(i in 1:2) {
                             g = as.numeric(reest_obj$gr(mle_spatial$par))
                             h = optimHess(mle_spatial$par, fn = reest_obj$fn, gr = reest_obj$gr)
                             mle_spatial$par = mle_spatial$par - solve(h,g)
                             mle_spatial$objective = reest_obj$fn(mle_spatial$par)
                           }
                         , error = function(e){e})
  
  try_improve
  
  mle_report = reest_obj$report(mle_spatial$par)
  
  a50_vec = c(a50_vec, mle_report$a50_movement)
  ato95_vec = c(ato95_vec, mle_report$ato95_movement)
  
  
  young_ogive = data.frame(age = data$ages, ogive = mle_report$young_age_based_movement_ogive, sim = sim_iter)
  old_ogive = data.frame(age = data$ages, ogive = mle_report$old_age_based_movement_ogive, sim = sim_iter)
  
  young_age_based_ogive_df_a50 = rbind(young_age_based_ogive_df_a50, young_ogive)
  old_age_based_ogive_df_a50 = rbind(old_age_based_ogive_df_a50, old_ogive)
  
  young_matrix = mle_report$movement_matrix_young
  old_matrix = mle_report$movement_matrix_old
  
  young_molten_move = melt(young_matrix)
  old_molten_move = melt(old_matrix)
  
  colnames(young_molten_move) = colnames(old_molten_move) = c("From", "To", "movement")
  young_molten_move$sim = sim_iter
  old_molten_move$sim = sim_iter
  
  young_matrix_df_a50 = rbind(young_matrix_df_a50, young_molten_move)
  old_matrix_df_a50 = rbind(old_matrix_df_a50, old_molten_move)
  
  nll_a50 = c(nll_a50, mle_spatial$objective)
}

ggplot(young_matrix_df_a50) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_young_molten_move, aes(yintercept = movement, col = "OM"), linewidth = 1.1, linetype = "dashed") +
  facet_grid(From~To) +
  ggtitle("Young movement rates") +
  ylim(0,1) +
  theme_bw()


ggplot(old_matrix_df_a50) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_old_molten_move, aes(yintercept = movement, col = "OM"), linewidth = 1.1, linetype = "dashed") +
  facet_grid(From~To)  +
  ggtitle("Old movement rates") +

  ylim(0,1) +
  theme_bw()

hist(a50_vec)
abline(v = a50_move, col = "red", lty = 2, lwd = 3)

```


## Simulation estimate a50 and a to95 parameter of age-based ogive {-}


```{r Esta50a95Ogive, echo = F}
###### set starting parameters
sim_ls = list();
young_age_based_ogive_df_a50_ato95 = old_age_based_ogive_df_a50_ato95 = NULL
young_matrix_df_a50_ato95 = old_matrix_df_a50_ato95 = NULL
a50_vec = ato95_vec = NULL
## fix selectivity parameters at true values
# fix at true values
start_parameters$logisitic_a50_movement = logit_general(4, data$a50_bounds[1], data$a50_bounds[2])
start_parameters$ln_ato95_movement = log(1)
nll_a50_ato95 = vector()
for(sim_iter in 1:n_sims){
  ## simulate data
  simdata = test_obj$simulate(complete = T)
  
  ## re-estimate
  reest_obj <- MakeADFun(data = simdata, parameters = start_parameters, DLL="SimpleAgeBasedMovement", silent = T)
  #reest_obj$fn()
  #reest_obj$gr()
  ## Estimate
  mle_spatial = nlminb(start = reest_obj$par, objective = reest_obj$fn, gradient  = reest_obj$gr, control = list(iter.max = 10000, eval.max = 10000))
  try_improve = tryCatch(expr =
                           for(i in 1:2) {
                             g = as.numeric(reest_obj$gr(mle_spatial$par))
                             h = optimHess(mle_spatial$par, fn = reest_obj$fn, gr = reest_obj$gr)
                             mle_spatial$par = mle_spatial$par - solve(h,g)
                             mle_spatial$objective = reest_obj$fn(mle_spatial$par)
                           }
                         , error = function(e){e})
  
  try_improve
  
  mle_report = reest_obj$report(mle_spatial$par)
  
  a50_vec = c(a50_vec, mle_report$a50_movement)
  ato95_vec = c(ato95_vec, mle_report$ato95_movement)
  
  
  young_ogive = data.frame(age = data$ages, ogive = mle_report$young_age_based_movement_ogive, sim = sim_iter)
  old_ogive = data.frame(age = data$ages, ogive = mle_report$old_age_based_movement_ogive, sim = sim_iter)
  
  young_age_based_ogive_df_a50_ato95 = rbind(young_age_based_ogive_df_a50_ato95, young_ogive)
  old_age_based_ogive_df_a50_ato95 = rbind(old_age_based_ogive_df_a50_ato95, old_ogive)
  
  young_matrix = mle_report$movement_matrix_young
  old_matrix = mle_report$movement_matrix_old
  
  young_molten_move = melt(young_matrix)
  old_molten_move = melt(old_matrix)
  
  colnames(young_molten_move) = colnames(old_molten_move) = c("From", "To", "movement")
  young_molten_move$sim = sim_iter
  old_molten_move$sim = sim_iter
  
  young_matrix_df_a50_ato95 = rbind(young_matrix_df_a50_ato95, young_molten_move)
  old_matrix_df_a50_ato95 = rbind(old_matrix_df_a50_ato95, old_molten_move)
  
  nll_a50_ato95 = c(nll_a50_ato95, mle_spatial$objective)
}
ggplot()+
  geom_line(data = young_age_based_ogive_df_a50_ato95, aes(x = age, y = ogive, col = "Young"), linewidth = 1.1, alpha = 0.4) +
  theme_bw()

ggplot(young_matrix_df_a50_ato95) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_young_molten_move, aes(yintercept = movement, col = "OM"), linewidth = 1.1, linetype = "dashed") +
  ggtitle("Young movement rates")+
  facet_grid(From~To) +
  ylim(0,1) +
  theme_bw()


ggplot(old_matrix_df_a50_ato95) +
  geom_boxplot(aes(y = movement)) +
  geom_hline(data = true_old_molten_move, aes(yintercept = movement, col = "OM"), linewidth = 1.1, linetype = "dashed") +
  ggtitle("old movement rates") +
  facet_grid(From~To)  +
  ylim(0,1) +
  theme_bw()



hist(a50_vec, main = "", ylab = "", xlab = "a50")
abline(v = a50_move, col = "red", lty = 2, lwd = 3)

hist(ato95_vec, main = "", ylab = "", xlab = "ato95")
abline(v = a95_move, col = "red", lty = 2, lwd = 3)


```




<!--chapter:end:13-EstimatingAgeBasedTagMovement.Rmd-->


# Tag likelihoods {#taglike}

Placeholder


## Likelihoods {-}
### Poisson {-}
### Negative Binomial {-}
### Multinomial:release conditioned {-}
### Recapture conditioned {-}
## Simple simulation {-}

<!--chapter:end:14-TagLikelihoods.Rmd-->


# Growth {#growth}

Placeholder


## Growth estimation using the Laslett–Eveson–Polacheck (LEP) method  {-}
### Age-at-length growth model {-}
### Tag recapture growth data {-}
## Simulation test the "LEP" method {-}
## Next steps {-}

<!--chapter:end:15-Growth.Rmd-->


# Review/summarise reference points {#refpoints}

Placeholder


## Spatial reference points {-}
### summarise @kritzer2004metapopulation {-}
### summarise @goethel2017accounting {-}
### summarise @kapur2021equilibrium {-}
### summarise @fenske2022implications {-}
### summarise @reuchlin2016spatial {-}

<!--chapter:end:16-ReferencePoints.Rmd-->


# Sex ratios in age and length composition data {#sexratios}

Placeholder


## A simple simulation {-}
### Results {-}
### Future research that was not considered in this simple simulation {-}
### Operating Model (OM) Parameters  {-}
### Scenario 1  {-}
#### EM 1 (using approach 1) {-}
#### EM 2 (using approach 2) {-}
#### EM 3 (using approach 1 with female fixed at \(\alpha = 1\)) {-}
### Scenario 2  {-}
#### EM 1 (using approach 1) {-}
#### EM 2 (using approach 2) {-}
#### EM 3 (using approach 1 with female fixed at \(\alpha = 1\)) {-}

<!--chapter:end:17-DealWithSexRatios.Rmd-->


# Fishing mortality approaches {#Fexplore}

Placeholder


## Set up a simulation {-}
## Appendix - Hybrid approach {-}

<!--chapter:end:18-ExploreFParameterisations.Rmd-->


# Initialising the plus group in spatial models {#spatialInit}

Placeholder



<!--chapter:end:19-InitialisingTheSpatialModel.Rmd-->


# Glossary of terms {#glossary}

Placeholder



<!--chapter:end:20-Glossary.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:22-references.Rmd-->

